apiVersion: batch/v1
kind: Job
metadata:
  name: generate-argocd-kubeconfig
  namespace: secrets
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-wave: "1"
spec:
  backoffLimit: 3
  template:
    spec:
      serviceAccountName: kubeconfig-generator
      restartPolicy: OnFailure
      containers:
        - name: generator
          image: bitnami/kubectl:latest
          imagePullPolicy: IfNotPresent
          command:
            - /bin/sh
            - -c
            - |
              set -euo pipefail
              echo "Starting kubeconfig generation from in-cluster credentials..."
              
              # Get in-cluster credentials
              TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              CA_CERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
              API_SERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
              
              echo "API Server: $API_SERVER"
              echo "Token found: $(echo "$TOKEN" | cut -c1-20)..."
              
              # Get namespace and service account name
              NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
              # Service account name is typically extracted from the token, but we can get it from the pod
              SERVICE_ACCOUNT="kubeconfig-generator"
              # Try to get from pod if available
              POD_NAME=$(hostname 2>/dev/null || echo "")
              if [ -n "$POD_NAME" ]; then
                SA_FROM_POD=$(kubectl get pod "$POD_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.serviceAccountName}' 2>/dev/null || echo "")
                [ -n "$SA_FROM_POD" ] && SERVICE_ACCOUNT="$SA_FROM_POD"
              fi
              
              echo "Using service account: $SERVICE_ACCOUNT in namespace: $NAMESPACE"
              
              # Base64 encode CA cert (portable across base64 implementations)
              CA_B64=$(base64 < "$CA_CERT" | tr -d '\n')
              
              # Create kubeconfig file using printf to avoid heredoc YAML parsing issues
              printf 'apiVersion: v1\nkind: Config\nclusters:\n- name: default-cluster\n  cluster:\n    server: %s\n    certificate-authority-data: %s\ncontexts:\n- name: default-context\n  context:\n    cluster: default-cluster\n    namespace: %s\n    user: %s\ncurrent-context: default-context\nusers:\n- name: %s\n  user:\n    token: %s\n' "$API_SERVER" "$CA_B64" "$NAMESPACE" "$SERVICE_ACCOUNT" "$SERVICE_ACCOUNT" "$TOKEN" > /tmp/kubeconfig
              
              echo "Generated kubeconfig file"
              
              # Verify kubeconfig is valid
              if kubectl --kubeconfig=/tmp/kubeconfig cluster-info >/dev/null 2>&1; then
                echo "✅ Kubeconfig validation successful"
              else
                echo "⚠️  Kubeconfig validation failed, but continuing..."
                kubectl --kubeconfig=/tmp/kubeconfig cluster-info || true
              fi
              
              # Base64 encode the kubeconfig for ConfigMap (portable)
              KUBE_B64=$(base64 < /tmp/kubeconfig | tr -d '\n')
              
              # Update secret in 'secrets' namespace (managed by ArgoCD from Git)
              echo "Updating secret cluster-kubeconfig in secrets namespace..."
              # Use patch to update data without deleting (preserves ArgoCD management)
              KUBE_B64_DATA=$(base64 < /tmp/kubeconfig | tr -d '\n')
              kubectl -n secrets patch secret cluster-kubeconfig \
                -p "{\"data\":{\"kubeconfig\":\"$KUBE_B64_DATA\"}}" \
                --type=merge 2>/dev/null || \
              kubectl -n secrets create secret generic cluster-kubeconfig \
                --from-file=kubeconfig=/tmp/kubeconfig \
                --dry-run=client -o yaml | \
              kubectl label --local -f - \
                app.kubernetes.io/name=cluster-kubeconfig \
                app.kubernetes.io/managed-by=argocd \
                purpose=cluster-access \
                -o yaml | \
              kubectl -n secrets apply -f -
              echo "✅ Secret cluster-kubeconfig updated in secrets namespace"
              
              # Update ConfigMap in 'secrets' namespace (managed by ArgoCD from Git)
              echo "Updating configmap cluster-kubeconfig-view in secrets namespace..."
              # Use patch to update data without deleting (preserves ArgoCD management)
              kubectl -n secrets patch configmap cluster-kubeconfig-view \
                -p "{\"data\":{\"kubeconfig.b64\":\"$KUBE_B64\",\"api-server\":\"$API_SERVER\",\"service-account\":\"$SERVICE_ACCOUNT\",\"namespace\":\"$NAMESPACE\"}}" \
                --type=merge 2>/dev/null || \
              kubectl -n secrets create configmap cluster-kubeconfig-view \
                --from-literal=kubeconfig.b64="$KUBE_B64" \
                --from-literal=instructions="Decode kubeconfig.b64 with: echo '<base64>' | base64 -d > kubeconfig" \
                --from-literal=api-server="$API_SERVER" \
                --from-literal=service-account="${SERVICE_ACCOUNT}" \
                --from-literal=namespace="${NAMESPACE}" \
                --dry-run=client -o yaml | \
              kubectl label --local -f - \
                app.kubernetes.io/name=cluster-kubeconfig \
                app.kubernetes.io/managed-by=argocd \
                purpose=cluster-access \
                -o yaml | \
              kubectl -n secrets apply -f -
              echo "✅ ConfigMap cluster-kubeconfig-view updated in secrets namespace"
              echo ""
              echo ""
              echo "Access your kubeconfig via ArgoCD UI:"
              echo "  1. Go to Applications > secrets-stack > Resources"
              echo "  2. Filter by label: purpose=cluster-access"
              echo "  3. View secret 'cluster-kubeconfig' or configmap 'cluster-kubeconfig-view' in secrets namespace"
      securityContext:
        runAsUser: 0
        runAsGroup: 0
